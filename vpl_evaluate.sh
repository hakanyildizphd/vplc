#!/usr/bin/python3

# Author: Hakan Yıldız
# Shared under MIT License. See the file LICENSE for more info.

####################
# PYLINT OVERRIDES #
####################
# We will not provide a module docstring.
#     pylint: disable = missing-module-docstring
# We use camel casing in this code.
#     pylint: disable = invalid-name
# We use unnecessary f-strings so that some strings are horizontally aligned.
#     pylint: disable = f-string-without-interpolation
# We have some complicated code.
#     pylint: disable = too-many-arguments, too-many-branches, too-many-statements


###########
# IMPORTS #
###########

from enum import Enum
from glob import glob
from multiprocessing import Process, Queue
from os import chmod, remove
from os.path import exists
from resource import RLIMIT_AS, RLIMIT_STACK, setrlimit
from shutil import copyfile
from signal import strsignal
from stat import S_IXUSR, S_IRUSR
from subprocess import check_output, STDOUT, TimeoutExpired, CalledProcessError
from time import time
from traceback import format_exc
from typing import Optional, List, Literal


#################
# CONFIGURATION #
#################

# The total grade for the task. Divided evenly among the available inputs.
TOTAL_GRADE : float = 100

# The time limit in seconds for each test run.
TIME_LIMIT_IN_SECONDS : float = 1.0

# Memory limit in MBs.
MEMORY_LIMIT_IN_MBS : int = 256

# Stack limit in MBs.
STACK_LIMIT_IN_MBS : int = 8

# The source files to compile to get the test subject, which is the program to be graded. If
# COMPILER is given as "python3", this should contain a single python file.
SOURCE_FILES : List[str] = ["homework.c"]

# The compiler/interpreter to use. If it is given as "python3", the compilation phase is skipped.
COMPILER : Literal["gcc", "g++", "python3"] = "gcc"

# The compiler/interpreter flags.
COMPILER_FLAGS : List[str] = ["-g", "-std=c17", "-w"]

# The time limit (in seconds) for the compilation.
COMPILER_TIMEOUT : float = 1.0

# The name of the executable file for the test subject.
EXECUTABLE_NAME : str = "StudentsSubmission"

# The file to which the test subject's output is forwarded.
OUTPUT_FILE : str = "StudentsOutput"

# The source files for the checker. If CHECKER_COMPILER is given as "python3", this should contain a
# single python file. The checker is a program that receives four command line arguments:
#     <input>: The input file against which the test subject is run.
#     <claimedOutput>: The output file generated by the test subject.
#     <correctOutput>: The file containing the expected output.
#     <isHidden>: A Boolean (0 or 1) that tells whether the test case is hidden. The checker should
#                 omit any diagnostic output if so.
# The checker should exit with code 0 and print out a message that contains a real number between 0
# and 1 (inclusively) that describes the grade, followed by a '|' sign, followed by a message (with
# possibly multiple lines). For instance:
#     0.5|Half points. The result is consistent but suboptimal.
CHECKER_SOURCE_FILES : List[str] = ["diff_checker_char.cpp"]

# The compiler/interpreter for the checker. The compilation is skipped if given as "python3".
CHECKER_COMPILER : Literal["gcc", "g++", "python3"] = "g++"

# The compiler/interpreter flags for the checker.
CHECKER_COMPILER_FLAGS : List[str] = ["-std=c++2a", "-w", "-O3", "-DSHOW_DIFF", "-DSHOW_OUTPUT"]

# The time limit (in seconds) given for the compilation of the checker.
CHECKER_COMPILER_TIMEOUT : float = 1.0

# The time limit (in seconds) for the checker itself, excluding the run of the test subject.
CHECKER_TIMEOUT : float = 1.0

# The name of the executable to produce.
CHECKER_EXECUTABLE_NAME : str = "Checker"

# Suffix for the input files. All files with this suffix is considered to be an input and therefore
# present a test case. The file name prior to the suffix is considered to be the label for the test
# case.
INPUT_SUFFIX : str = ".in"

# Suffix for the output files. Each input file should have a corresponding output file with this
# suffix, completing the test case.
OUTPUT_SUFFIX : str = ".out"

# Whether we show the input/output contents prior to running each test case.
SHOW_INPUT_OUTPUT : bool = True

# Test cases with inputs that bear this suffix (prior to their INPUT_SUFFIX) are considered to be
# hidden. Setting SHOW_INPUT_OUTPUT as true does not apply to hidden test cases: Their input/output
# would remain hidden. The hidden status of a test case is also specified to the checker via its
# <isHidden> parameter: The checker should refrain from any diagnostic outputs that can reveal the
# test case. Finally, note that this suffix itself is removed from the label for the test case.
HIDDEN_SUFFIX : Optional[str] = "hidden"


########
# CODE #
########

def printFormatted(msg : str):
    """Prints a string with necessary formatting so that it is pretty in the VPL output."""
    print(msg)
    # TODO: Formatted print looking nice both on "Edit" and "View Submission" modes.
    # for line in msg.split("\n"):
    #     print(">" + line)

class ExecuteResultStatus(Enum):
    """Represents the result status of a program execution."""
    Success = 0
    NonZeroExitCode = 1
    TimeLimitExceeded = 2
    CompilationFailed = 3

class ExecuteResult:
    """Represents the result of a program execution."""
    _status : ExecuteResultStatus
    _elapsedTimeInSeconds : float
    _nonZeroExitCode : Optional[int]
    _output : Optional[str]
    #
    def __init__(self, *,
                 status : ExecuteResultStatus,
                 elapsedTimeInSeconds : float,
                 nonZeroExitCode : Optional[int],
                 output : Optional[str]):
        self._status = status
        self._elapsedTimeInSeconds = elapsedTimeInSeconds
        self._nonZeroExitCode = nonZeroExitCode
        self._output = output
    # Pylint overrides for the upcoming accessors.
    #     pylint: disable = missing-function-docstring, multiple-statements
    @property
    def status(self) -> ExecuteResultStatus: return self._status
    @property
    def elapsedTimeInSeconds(self) -> float: return self._elapsedTimeInSeconds
    @property
    def nonZeroExitCode(self) -> Optional[int]: return self._nonZeroExitCode
    @property
    def output(self) -> Optional[str]: return self._output
    @property
    def likelySignal(self) -> Optional[str]:
        if self._nonZeroExitCode is not None:
            # noinspection PyBroadException
            try:
                return strsignal(-self._nonZeroExitCode)
            # TODO: Cautiously, make the exception more specific in the future.
            except: # pylint: disable = bare-except
                return None
        else:
            return None

# Represents an executable that is compiled from sources. Compilation is done upon construction.
class ExecutableFromSources: # pylint: disable = too-few-public-methods
    '''
    Represents an executable program, referred with its sources. Compilation/preparation occurs
    during construction.
    '''
    _name : str
    _args : List[str]
    _compilationSuccessful : bool
    #
    def __init__(self,
                 *,
                 name : str,
                 sources : List[str],
                 compiler : Literal["gcc", "g++", "python3"],
                 flags : List[str],
                 compilationTimeout : float,
                 delayErrorToExecution : bool):
        assert name.isalnum()
        self._name = name
        if compiler == "python3":
            assert len(sources) == 1
            print(f"[INFO] Copying {name}...")
            try:
                copyfile(sources[0], name)
                self._args = ["/usr/bin/python3"] + flags + [name]
                self._compilationSuccessful = True
                print("[SUCCESS] Copy finished.")
                print()
            except Exception as e: # pylint: disable = broad-exception-caught
                self._args = []
                self._compilationSuccessful = False
                if not delayErrorToExecution:
                    raise e
        else:
            assert compiler in ("gcc", "g++"), "Unexpected compiler."
            print(f"[INFO] Compiling {name}...")
            print("[INFO] Compiler flags:", " ".join(flags))
            compileCommand = [compiler] + sources + ["-o", name] + flags
            try:
                compileOutput : str = check_output(compileCommand,
                                                   stderr=STDOUT,
                                                   timeout=compilationTimeout).decode("utf-8")
                self._args = [f"./{name}"]
                self._compilationSuccessful = True
                print("[SUCCESS] Compilation finished.")
                compileOutput = compileOutput.strip()
                if compileOutput != "":
                    print("[INFO] Compiler Output:")
                    printFormatted(compileOutput.strip())
                print()
            except CalledProcessError as cpe:
                self._args = []
                self._compilationSuccessful = False
                print("[ERROR] Compilation failed.")
                print("[INFO] Compiler Output:")
                printFormatted(cpe.output.decode("utf-8"))
                print()
                if not delayErrorToExecution:
                    raise cpe
            except TimeoutExpired as te:
                self._args = []
                self._compilationSuccessful = False
                print("[ERROR] Compilation timed out.")
                print()
                if not delayErrorToExecution:
                    raise te
    #
    def _execute(self,
                 *,
                 args : List[str],
                 stdinFile : Optional[str],
                 stdoutFile : Optional[str],
                 timeLimitInSeconds : float,
                 memoryLimitInMbs : Optional[int],
                 stackLimitInMbs : Optional[int]) -> ExecuteResult:
        # Check if the executable is compiled.
        if not self._compilationSuccessful:
            return ExecuteResult(status = ExecuteResultStatus.CompilationFailed,
                                 elapsedTimeInSeconds = 0.0,
                                 nonZeroExitCode = None,
                                 output = None)
        # Set resource limits.
        if memoryLimitInMbs is not None:
            setrlimit(RLIMIT_AS, (memoryLimitInMbs * 1024 * 1024, -1))
        if stackLimitInMbs is not None:
            setrlimit(RLIMIT_STACK, (stackLimitInMbs * 1024 * 1024, -1))
        # Execute.
        startTime = time()
        #
        try:
            if stdinFile is not None:
                with open(stdinFile, "rb") as inputStream:
                    output = check_output(self._args + args,
                                          stdin = inputStream,
                                          stderr = STDOUT,
                                          timeout = timeLimitInSeconds)
            else:
                output = check_output(self._args + args,
                                      stderr = STDOUT,
                                      timeout = timeLimitInSeconds)
        except TimeoutExpired:
            return ExecuteResult(status = ExecuteResultStatus.TimeLimitExceeded,
                                 elapsedTimeInSeconds = time() - startTime,
                                 nonZeroExitCode = None,
                                 output = None)
        except CalledProcessError as cpe:
            return ExecuteResult(status = ExecuteResultStatus.NonZeroExitCode,
                                 elapsedTimeInSeconds = time() - startTime,
                                 nonZeroExitCode = cpe.returncode,
                                 output = None)
        except:
            print(f"Unexpected error while executing {self._name}.")
            raise
        #
        elapsedTime = time() - startTime
        if stdoutFile is not None:
            with open(stdoutFile, "wb") as outputStream:
                outputStream.write(output)
        return ExecuteResult(status = ExecuteResultStatus.Success,
                             elapsedTimeInSeconds = elapsedTime,
                             nonZeroExitCode = None,
                             output = None if (stdoutFile is not None) else output.decode("utf-8"))
    #
    def _executeSlave(self,
                      *,
                      args: List[str],
                      stdinFile: Optional[str],
                      stdoutFile: Optional[str],
                      timeLimitInSeconds: float,
                      memoryLimitInMbs: Optional[int],
                      stackLimitInMbs: Optional[int],
                      queue: "Queue[ExecuteResult]") -> None:  # TODO: Fix type hint in the future.
        queue.put(self._execute(args = args,
                                stdinFile = stdinFile,
                                stdoutFile = stdoutFile,
                                timeLimitInSeconds = timeLimitInSeconds,
                                memoryLimitInMbs = memoryLimitInMbs,
                                stackLimitInMbs = stackLimitInMbs))
    #
    def execute(self,
                *,
                args : List[str],
                stdinFile : Optional[str],
                stdoutFile : Optional[str],
                timeLimitInSeconds : float,
                memoryLimitInMbs : Optional[int],
                stackLimitInMbs : Optional[int]) -> ExecuteResult:
        """Executes the program."""
        # If you wanted to execute without the slave process, it would look like this:
        #     return self._execute(args = args,
        #                          stdinFile = stdinFile,
        #                          stdoutFile = stdoutFile,
        #                          timeLimitInSeconds = timeLimitInSeconds,
        #                          memoryLimitInMbs = memoryLimitInMbs,
        #                          stackLimitInMbs = stackLimitInMbs)
        # This would put the memory/stack limits on this process, though.
        q : "Queue[ExecuteResult]" = Queue() # TODO: Fix type hint in the future.
        p = Process(target = self._executeSlave,
                    args=(),
                    kwargs={"args": args,
                            "stdinFile": stdinFile,
                            "stdoutFile": stdoutFile,
                            "timeLimitInSeconds": timeLimitInSeconds,
                            "memoryLimitInMbs": memoryLimitInMbs,
                            "stackLimitInMbs": stackLimitInMbs,
                            "queue": q})
        p.start()
        p.join()
        # noinspection PyBroadException
        try:
            return q.get(block = False)
        except Exception as e:
            raise RuntimeError("The slave process did not communicate as expected.") from e

class TestCase:
    '''Represents a test case.'''
    _label : str
    _inputFile : str
    _outputFile : str
    _grade : float
    _hidden : bool
    def __init__(self, *, label : str, inputFile : str, outputFile : str, grade : float,
                 hidden : bool):
        self._label = label
        self._inputFile = inputFile
        self._outputFile = outputFile
        self._grade = grade
        self._hidden = hidden
    # Pylint overrides for the upcoming accessors.
    #     pylint: disable = missing-function-docstring, multiple-statements
    @property
    def label(self) -> str: return self._label
    @property
    def inputFile(self) -> str: return self._inputFile
    @property
    def outputFile(self) -> str: return self._outputFile
    @property
    def grade(self) -> float: return self._grade
    @property
    def hidden(self) -> bool: return self._hidden

def getTestCases(*, totalGrade : float) -> List[TestCase]:
    '''Obtains a list of available test cases.'''
    cases : List[TestCase] = []
    inputFiles = sorted(glob("*" + INPUT_SUFFIX))
    assert len(inputFiles) > 0, "There are no input files."
    gradePerInput : float = totalGrade / len(inputFiles)
    for inputFile in inputFiles:
        inputFileWithoutInputSuffix = inputFile[:-len(INPUT_SUFFIX)]
        outputFile = inputFileWithoutInputSuffix + OUTPUT_SUFFIX
        assert exists(outputFile), f"{outputFile} is missing."
        #
        hidden : bool
        label : str
        if HIDDEN_SUFFIX is not None and inputFileWithoutInputSuffix.endswith(HIDDEN_SUFFIX):
            hidden = True
            label = inputFileWithoutInputSuffix if HIDDEN_SUFFIX == ""\
                    else inputFileWithoutInputSuffix[:-len(HIDDEN_SUFFIX)]
        else:
            hidden = False
            label = inputFileWithoutInputSuffix
        #
        cases.append(TestCase(label = label,
                              inputFile = inputFile,
                              outputFile = outputFile,
                              grade = gradePerInput,
                              hidden = hidden))
    return cases

def evaluate(*,
             testCase : TestCase,
             testSubject : ExecutableFromSources,
             checker : ExecutableFromSources) -> float:
    '''Evaluates the given test subject on the given test case with the given checker.'''
    print(f"[INPUT] {testCase.label} ({testCase.grade:.2f} pts)")
    if SHOW_INPUT_OUTPUT:
        if testCase.hidden:
            print("[INFO] The input/output is intentionally hidden.")
        else:
            print("Input:")
            with open(testCase.inputFile, "r", encoding = "utf-8") as stream:
                data = stream.read()
                if data.endswith("\n"):
                    data = data[0:-1]
                printFormatted(data)
            print("Expected output:")
            with open(testCase.outputFile, "r", encoding = "utf-8") as stream:
                data = stream.read()
                if data.endswith("\n"):
                    data = data[0:-1]
                printFormatted(data)
    result : ExecuteResult = testSubject.execute(args = [],
                                                 stdinFile = testCase.inputFile,
                                                 stdoutFile = OUTPUT_FILE,
                                                 timeLimitInSeconds = TIME_LIMIT_IN_SECONDS,
                                                 memoryLimitInMbs = MEMORY_LIMIT_IN_MBS,
                                                 stackLimitInMbs = STACK_LIMIT_IN_MBS)
    if result.status == ExecuteResultStatus.CompilationFailed:
        print(f"[INCORRECT] Prior compilation failed.")
        grade = 0.0
    elif result.status == ExecuteResultStatus.TimeLimitExceeded:
        print(f"[INCORRECT] Time limit exceeded.")
        print(f"[INFO] Elapsed time was {result.elapsedTimeInSeconds:.2f} seconds.")
        grade = 0.0
    elif result.status == ExecuteResultStatus.NonZeroExitCode:
        signal = "" if (result.likelySignal is None) else f" ({result.likelySignal})"
        print(f"[INCORRECT] Program returned {result.nonZeroExitCode}." + signal)
        print(f"[INFO] Exceeding the memory/stack limits *MAY* be the issue.")
        print(f"[INFO] Elapsed time was {result.elapsedTimeInSeconds:.2f} seconds.")
        grade = 0.0
    else:
        assert result.status == ExecuteResultStatus.Success
        checkerResult = checker.execute(args = [testCase.inputFile,
                                                OUTPUT_FILE,
                                                testCase.outputFile,
                                                "1" if testCase.hidden else "0"],
                                        stdinFile = None,
                                        stdoutFile = None,
                                        timeLimitInSeconds = CHECKER_TIMEOUT,
                                        memoryLimitInMbs = None,
                                        stackLimitInMbs = None)
        try:
            assert checkerResult.status == ExecuteResultStatus.Success, \
                   f"Checker execution failed. Status: {checkerResult.status}."
            assert checkerResult.output is not None, "Checker output not obtained."
            assert "|" in checkerResult.output, "Checker output format is incorrect."
            gradeRatioAsStr, output = checkerResult.output.split("|", maxsplit = 1)
            gradeRatio = float(gradeRatioAsStr)
            assert 0.0 <= gradeRatio <= 1.0, "Checker gave invalid grade."
            if gradeRatio == 1.0:
                gradeText = "CORRECT"
            elif gradeRatio == 0.0:
                gradeText = "INCORRECT"
            else:
                gradeText = "PARTIAL"
            output = output.strip()
            print(f"[{gradeText}] {output}")
        # TODO: How do I (and should I) catch every exception in here?
        except Exception as e: # pylint: disable = broad-exception-caught
            print(f"[FAILURE] Checker failed: {type(e).__name__}/{e}. No points.")
            gradeRatio = 0.0
        #
        print(f"[INFO] Elapsed time was {result.elapsedTimeInSeconds:.2f} seconds.")
        print(f"[INFO] Checker ran for {checkerResult.elapsedTimeInSeconds:.2f} seconds.")
        grade = gradeRatio * testCase.grade
    print(f"[POINTS] {grade:.2f} / {testCase.grade:.2f}")
    print()
    return grade

def conveyGrade(*, grade : float, totalGrade : float):
    '''Prints the grade and generates the necessary files for grade reporting.'''
    print(f"[GRADE] Your grade is {grade:.2f} / {totalGrade:.2f}.")
    print()
    if exists("vpl_execution"):
        remove("vpl_execution")
    with open("vpl_execution", "w", encoding = "utf-8") as vplExecution:
        vplExecution.write("#!/bin/bash\n")
        vplExecution.write("printf \"Grade :=>> " + str(grade) + "\"")
    chmod("vpl_execution", S_IXUSR | S_IRUSR)

def main():
    '''Main function.'''
    # Prepare checker.
    checker = ExecutableFromSources(name = CHECKER_EXECUTABLE_NAME,
                                    sources = CHECKER_SOURCE_FILES,
                                    compiler = CHECKER_COMPILER,
                                    flags = CHECKER_COMPILER_FLAGS,
                                    compilationTimeout = CHECKER_COMPILER_TIMEOUT,
                                    delayErrorToExecution = False)
    # Prepare test subject.
    testSubject = ExecutableFromSources(name = EXECUTABLE_NAME,
                                        sources = SOURCE_FILES,
                                        compiler = COMPILER,
                                        flags = COMPILER_FLAGS,
                                        compilationTimeout = COMPILER_TIMEOUT,
                                        delayErrorToExecution = True)
    # Evaluate.
    grade = 0
    for case in getTestCases(totalGrade = TOTAL_GRADE):
        grade = grade + evaluate(testCase = case,
                                 testSubject = testSubject,
                                 checker = checker)
    # Convey the overall grade.
    conveyGrade(grade = grade, totalGrade = TOTAL_GRADE)

try:
    main()
# TODO: How do I (and should I) catch every exception in here?
except Exception as exception: # pylint: disable = broad-exception-caught
    print(f"[UNEXPECTED ERROR]")
    print(f"{type(exception).__name__}")
    print(f"{exception}")
    print(f"{format_exc()}")
